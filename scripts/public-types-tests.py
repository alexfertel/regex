#!/usr/bin/env python3

from subprocess import run
import argparse
import datetime
import json
import os

PREAMBLE = """
// DO NOT EDIT. Automatically generated by 'scripts/public-traits-tests.py'
// on {date}.
""".lstrip()

CMD = [
    "cargo",
    "rustdoc",
    "-q",
    "--",
    "-Z",
    "unstable-options",
    "--output-format",
    "json",
]


def get_public_of_kind(kinds, elements, index):
    keys_of_kind = filter(lambda key: index[key]["kind"] in kinds, elements)
    public_of_kind = filter(
        lambda key: index[key]["visibility"] == "public", keys_of_kind
    )
    return map(lambda key: index[key], public_of_kind)


def gen_test(path):
    tests = [
        f"\tassert_send::<{path}>();",
        f"\tassert_sync::<{path}>();",
        f"\tassert_unwind_safe::<{path}>();",
        f"\tassert_ref_unwind_safe::<{path}>();",
        "",
    ]
    return "\n".join(tests)


def gen_docs():
    doc_gen_result = run(CMD)
    if doc_gen_result.returncode != 0:
        print("Unable to generate the docs for the regex")
        exit(1)


def get_public_types():
    with open(os.path.join("target", "doc", "regex.json")) as docs_file:
        docs = json.load(docs_file)
        index = docs["index"]

        type_paths = []
        public_modules = get_public_of_kind(["module"], index.keys(), index)
        for mod in public_modules:
            types = get_public_of_kind(["struct"], mod["inner"]["items"], index)
            for type in types:
                prefix = "" if mod["inner"]["is_crate"] else "regex::"
                type_path = f"{prefix}{mod['name']}::{type['name']}"
                type_paths.append(type_path)

        return type_paths


def gen_tests():
    tests = []
    types = get_public_types()
    for type in types:
        tests.append("")
        test = gen_test(type)
        tests.append(test)

    return tests


def get_assert_definitions():
    definitions = [
        "\tfn assert_send<T: Send>() {}",
        "\tfn assert_sync<T: Sync>() {}",
        "\tfn assert_unwind_safe<T: UnwindSafe>() {}",
        "\tfn assert_ref_unwind_safe<T: RefUnwindSafe>() {}",
    ]
    return "\n".join(definitions)


def write_tests():
    with open(os.path.join("tests", "marker_traits.rs"), "w") as f:
        f.write(PREAMBLE.format(date=str(datetime.datetime.now())))
        f.write("\n")
        f.write("#[test]\nfn marker_traits() {\n")
        f.write("\tuse std::panic::{RefUnwindSafe, UnwindSafe};\n")
        f.write("\n")
        f.write(get_assert_definitions())
        f.write("\n")
        for test in gen_tests():
            f.write(f"{test}\n")
        f.write("}\n")


def check_existence():
    types = get_public_types()
    with open(os.path.join("tests", "marker_traits.rs")) as f:
        lines = f.readlines()
        for type in types:
            if any(type in line for line in lines):
                continue
            else:
                exit(1)

    exit(0)


def main():
    p = argparse.ArgumentParser(
        "A script to manage marker-traits tests.",
        description="Checks for the existence of tests for the public API types, "
        "failing when there are missing tests for a marker trait of "
        "a type.",
    )
    p.add_argument(
        "-g",
        "--generate-tests",
        action="store_true",
        help=(
            "If set, the script will generate a "
            "tests/marker_traits.rs file containing a test that "
            "checks the auto traits of the public API types "
            "(These tests might need to be updated after generating them)."
        ),
    )

    args = p.parse_args()

    gen_docs()

    if args.generate_tests:
        write_tests()
    else:
        check_existence()


if __name__ == "__main__":
    main()
